%% --------------------------------------------------
%% DO NOT EDIT THIS FILE
%% It was generated automatically from the following specs
%% mustache-spec/specs/~dynamic-names.json
%% Fetched from this repository
%% https://github.com/mustache/spec
%%
%% date: 2022-11-03 00:03:16
%% @version v0.0.0
%% @reference Eptwalabha, https://github.com/Eptwalabha.
%%
%% @doc Rationale: this special notation was introduced primarily to allow the
%% dynamic
%% loading of partials. The main advantage that this notation offers is to
%% allow
%% dynamic loading of partials, which is particularly useful in cases where
%% polymorphic data needs to be rendered in different ways. Such cases would
%% otherwise be possible to render only with solutions that are convoluted,
%% inefficient, or both.
%%
%% Example.
%% Let's consider the following data:
%%
%% items: [
%% { content: 'Hello, World!' },
%% { url: 'http://example.com/foo.jpg' },
%% { content: 'Some text' },
%% { content: 'Some other text' },
%% { url: 'http://example.com/bar.jpg' },
%% { url: 'http://example.com/baz.jpg' },
%% { content: 'Last text here' }
%% ]
%%
%% The goal is to render the different types of items in different ways. The
%% items having a key named `content` should be rendered with the template
%% `text.mustache`:
%%
%% {{!text.mustache}}
%% {{content}}
%%
%% And the items having a key named `url` should be rendered with the template
%% `image.mustache`:
%%
%% {{!image.mustache}}
%% <img src="{{url}}"/>
%%
%% There are already several ways to achieve this goal, here below are
%% illustrated and discussed the most significant solutions to this problem.
%%
%% Using Pre-Processing
%%
%% The idea is to use a secondary templating mechanism to dynamically generate
%% the template that will be rendered.
%% The template that our secondary templating mechanism generates might look
%% like this:
%%
%% {{!template.mustache}}
%% {{items.1.content}}
%% <img src="{{items.2.url}}"/>
%% {{items.3.content}}
%% {{items.4.content}}
%% <img src="{{items.5.url}}"/>
%% <img src="{{items.6.url}}"/>
%% {{items.7.content}}
%%
%% This solutions offers the advantages of having more control over the
%% template
%% and minimizing the template blocks to the essential ones.
%% The drawbacks are the rendering speed and the complexity that the secondary
%% templating mechanism requires.
%%
%% Using Lambdas
%%
%% The idea is to inject functions into the data that will be later called from
%% the template.
%% This way the data will look like this:
%%
%% items: [
%% {
%% content: 'Hello, World!',
%% html: function() { return '{{>text}}'; }
%% },
%% {
%% url: 'http://example.com/foo.jpg',
%% html: function() { return '{{>image}}'; }
%% },
%% {
%% content: 'Some text',
%% html: function() { return '{{>text}}'; }
%% },
%% {
%% content: 'Some other text',
%% html: function() { return '{{>text}}'; }
%% },
%% {
%% url: 'http://example.com/bar.jpg',
%% html: function() { return '{{>image}}'; }
%% },
%% {
%% url: 'http://example.com/baz.jpg',
%% html: function() { return '{{>image}}'; }
%% },
%% {
%% content: 'Last text here',
%% html: function() { return '{{>text}}'; }
%% }
%% ]
%%
%% And the template will look like this:
%%
%% {{!template.mustache}}
%% {{#items}}
%% {{{html}}}
%% {{/items}}
%%
%% The advantage this solution offers is to have a light main template.
%% The drawback is that the data needs to embed logic and template tags in
%% it.
%%
%% Using If-Else Blocks
%%
%% The idea is to put some logic into the main template so it can select the
%% templates at rendering time:
%%
%% {{!template.mustache}}
%% {{#items}}
%% {{#url}}
%% {{>image}}
%% {{/url}}
%% {{#content}}
%% {{>text}}
%% {{/content}}
%% {{/items}}
%%
%% The main advantage of this solution is that it works without adding any
%% overhead fields to the data. It also documents which external templates are
%% appropriate for expansion in this position.
%% The drawback is that this solution isn't optimal for heterogeneous data sets
%% as the main template grows linearly with the number of polymorphic variants.
%%
%% Using Dynamic Names
%%
%% This is the solution proposed by this spec.
%% The idea is to load partials dynamically.
%% This way the data items have to be tagged with the corresponding partial
%% name:
%%
%% items: [
%% { content: 'Hello, World!', dynamic: 'text' },
%% { url: 'http://example.com/foo.jpg', dynamic: 'image' },
%% { content: 'Some text', dynamic: 'text' },
%% { content: 'Some other text', dynamic: 'text' },
%% { url: 'http://example.com/bar.jpg', dynamic: 'image' },
%% { url: 'http://example.com/baz.jpg', dynamic: 'image' },
%% { content: 'Last text here', dynamic: 'text' }
%% ]
%%
%% And the template would simple look like this:
%%
%% {{!template.mustache}}
%% {{#items}}
%% {{>*dynamic}}
%% {{/items}}
%%
%% Summary:
%%
%% +----------------+---------------------+-----------------------------------+
%% | Approach | Pros | Cons |
%% +----------------+---------------------+-----------------------------------+
%% | Pre-Processing | Essential template, | Secondary templating system |
%% | | more control | needed, slower rendering |
%% | Lambdas | Slim template | Data tagging, logic in data |
%% | If Blocks | No data overhead, | Template linear growth |
%% | | self-documenting | |
%% | Dynamic Names | Slim template | Data tagging |
%% +----------------+---------------------+-----------------------------------+
%%
%% Dynamic Names are a special notation to dynamically determine a tag's
%% content.
%%
%% Dynamic Names MUST be a non-whitespace character sequence NOT containing
%% the current closing delimiter. A Dynamic Name consists of an asterisk,
%% followed by a dotted name. The dotted name follows the same notation as in
%% an
%% Interpolation tag.
%%
%% This tag's dotted name, which is the Dynamic Name excluding the
%% leading asterisk, references a key in the context whose value will be used
%% in
%% place of the Dynamic Name itself as content of the tag. The dotted name
%% resolution produces the same value as an Interpolation tag and does not
%% affect
%% the context for further processing.
%%
%% Set Delimiter tags MUST NOT affect the resolution of a Dynamic Name. The
%% Dynamic Names MUST be resolved against the context stack local to the tag.
%% Failed resolution of the dynamic name SHOULD result in nothing being
%% rendered.
%%
%% Engines that implement Dynamic Names MUST support their use in Partial tags.
%% In engines that also implement the optional inheritance spec, Dynamic Names
%% inside Parent tags SHOULD be supported as well. Dynamic Names cannot be
%% resolved more than once (Dynamic Names cannot be nested).
%%
%% @end

-module(dynamic_names_test).

-include_lib("eunit/include/eunit.hrl").

-define(TO_LIST(Something), unicode:characters_to_list(Something)).

%% @doc The asterisk operator is used for dynamic partials.
basic_behavior_partial_test() ->
    Template = <<"\"{{>*dynamic}}\"">>,
    Data = #{dynamic => <<"content">>},
    Partials = #{ content => "Hello, world!" },
    Expected = <<"\"Hello, world!\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc The asterisk is not part of the name that will be resolved in the
%% context.
%%
%% @end
basic_behavior_name_resolution_test() ->
    Template = <<"\"{{>*dynamic}}\"">>,
    Data = #{'*dynamic' => <<"wrong">>,dynamic => <<"content">>},
    Partials = #{ content => <<"Hello, world!">>,
                  wrong => <<"Invisible">> },
    Expected = <<"\"Hello, world!\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Failed context lookups should be considered falsey.
context_misses_partial_test() ->
    Template = <<"\"{{>*missing}}\"">>,
    Data = #{},
    Partials = #{ missing => <<"Hello, world!">> },
    Expected = <<"\"\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc The empty string should be used when the named partial is not found.
failed_lookup_partial_test() ->
    Template = <<"\"{{>*dynamic}}\"">>,
    Data = #{dynamic => <<"content">>},
    Partials = #{ foobar => <<"Hello, world!">> },
    Expected = <<"\"\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc The dynamic partial should operate within the current context.
context_test() ->
    Template = <<"\"{{>*example}}\"">>,
    Data = #{example => <<"partial">>,text => <<"Hello, world!">>},
    Partials = #{ partial => <<"*{{text}}*">> },
    Expected = <<"\"*Hello, world!*\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc The dynamic partial should operate within the current context.
dotted_names_test() ->
    Template = <<"\"{{>*foo.bar.baz}}\"">>,
    Data = #{foo => #{bar => #{baz => <<"partial">>}},
             text => <<"Hello, world!">>},
    Partials = #{ partial => <<"*{{text}}*">> },
    Expected = <<"\"*Hello, world!*\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc The dotted name should be resolved entirely before being dereferenced.
dotted_names_operator_precedence_test() ->
    Template = <<"\"{{>*foo.bar.baz}}\"">>,
    Data = #{foo => <<"test">>,
             test => #{bar => #{baz => <<"partial">>}},
             text => <<"Hello, world!">>},
    Partials = #{ partial => <<"*{{text}}*">> },
    Expected = <<"\"\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc The dynamic partial should operate within the current context.
dotted_names_failed_lookup_test() ->
    Template = <<"\"{{>*foo.bar.baz}}\"">>,
    Data = #{foo =>
                 #{bar => #{baz => <<"partial">>},
                   text => <<"Hello, world!">>}},
    Partials = #{ partial => <<"*{{text}}*">> },
    Expected = <<"\"**\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Dotted names should not push a new frame on the context stack.
dotted_names_context_stacking_test() ->
    Template = <<"{{#section1}}{{>*section2.dynamic}}{{/section1}}">>,
    Data = #{section1 => #{value => <<"section1">>},
             section2 => #{dynamic => <<"partial">>,value => <<"section2">>}},
    Partials = #{ partial => <<"\"{{value}}\"">> },
    Expected = <<"\"section1\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Dotted names should not push a new frame on the context stack.
dotted_names_context_stacking_under_repetition_test() ->
    Template = <<"{{#section1}}{{>*section2.dynamic}}{{/section1}}">>,
    Data = #{section1 => [1,2],
             section2 => #{dynamic => <<"partial">>,value => <<"section2">>},
             value => <<"test">>},
    Partials = #{ partial => <<"{{value}}">> },
    Expected = <<"testtest">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Dotted names should resolve against the proper context stack.
dotted_names_context_stacking_failed_lookup_test() ->
    Template = <<"{{#section1}}{{>*section2.dynamic}}{{/section1}}">>,
    Data = #{section1 => [1,2],
             section2 => #{dynamic => <<"partial">>,value => <<"section2">>}},
    Partials = #{ partial => <<"\"{{value}}\"">> },
    Expected = <<"\"\"\"\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Dynamic partials should properly recurse.
recursion_test() ->
    Template = <<"{{>*template}}">>,
    Data = #{content => <<"X">>,
             nodes => [#{content => <<"Y">>,nodes => []}],
             template => <<"node">>},
    Partials = #{ node => <<"{{content}}<{{#nodes}}{{>*template}}{{/nodes}}>">> },
    Expected = <<"X<Y<>>">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Dynamic Names can't be dereferenced more than once.
dynamic_names_double_dereferencing_test() ->
    Template = <<"\"{{>**dynamic}}\"">>,
    Data = #{dynamic => <<"test">>,test => <<"content">>},
    Partials = #{ content => <<"Hello, world!">> },
    Expected = <<"\"\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Dotted Names are resolved entirely before dereferencing begins.
dynamic_names_composed_dereferencing_test() ->
    Template = <<"\"{{>*foo.*bar}}\"">>,
    Data = #{bar => <<"buzz">>,
             fizz => #{buzz => #{content => null}},
             foo => <<"fizz">>},
    Partials = #{ content => <<"Hello, world!">> },
    Expected = <<"\"\"">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc A dynamic partial should not alter surrounding whitespace; any
%% whitespace preceding the tag should be treated as indentation while any
%% whitespace succeding the tag should be left untouched.
%% @end
surrounding_whitespace_test() ->
    Template = <<"| {{>*partial}} |">>,
    Data = #{partial => <<"foobar">>},
    Partials = #{ foobar => <<"\t|\t">> },
    Expected = <<"| \t|\t |">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Whitespace should be left untouched: whitespaces preceding the tag
%% should be treated as indentation.
%% @end
inline_indentation_test() ->
    Template = <<"  {{data}}  {{>*dynamic}}\n">>,
    Data = #{data => <<"|">>,dynamic => <<"partial">>},
    Partials = #{ partial => <<">\n>">> },
    Expected = <<"  |  >\n>\n">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc "\r\n" should be considered a newline for standalone tags.
standalone_line_endings_test() ->
    Template = <<"|\r\n{{>*dynamic}}\r\n|">>,
    Data = #{dynamic => <<"partial">>},
    Partials = #{ partial => <<">">> },
    Expected = <<"|\r\n>|">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Standalone tags should not require a newline to precede them.
standalone_without_previous_line_test() ->
    Template = <<"  {{>*dynamic}}\n>">>,
    Data = #{dynamic => <<"partial">>},
    Partials = #{ partial => <<">\n>">> },
    Expected = <<"  >\n  >>">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Standalone tags should not require a newline to follow them.
standalone_without_newline_test() ->
    Template = <<">\n  {{>*dynamic}}">>,
    Data = #{dynamic => <<"partial">>},
    Partials = #{ partial => <<">\n>">> },
    Expected = <<">\n  >\n  >">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Each line of the partial should be indented before rendering.
standalone_indentation_test() ->
    Template = <<"\\\n {{>*dynamic}}\n/\n">>,
    Data = #{content => <<"<\n->">>,dynamic => <<"partial">>},
    Partials = #{ partial => <<"|\n{{{content}}}\n|\n">> },
    Expected = <<"\\\n |\n <\n->\n |\n/\n">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Superfluous in-tag whitespace should be ignored.
padding_whitespace_test() ->
    Template = <<"|{{> * dynamic }}|">>,
    Data = #{boolean => true,dynamic => <<"partial">>},
    Partials = #{ partial => <<"[]">> },
    Expected = <<"|[]|">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).
