%% --------------------------------------------------
%% DO NOT EDIT THIS FILE
%% It was generated automatically from the following specs
%% ./mustache-spec/specs/sections.json
%% Fetched from this repository
%% https://github.com/mustache/spec
%%
%% date: 2022-10-20 19:49:18
%% @version v0.0.0
%% @reference Eptwalabha, https://github.com/Eptwalabha.
%%
%% @doc Section tags and End Section tags are used in combination to wrap a
%% section
%% of the template for iteration
%%
%% These tags' content MUST be a non-whitespace character sequence NOT
%% containing the current closing delimiter; each Section tag MUST be followed
%% by an End Section tag with the same content within the same section.
%%
%% This tag's content names the data to replaceÂ the tag. Name resolution is as
%% follows:
%% 1) Split the name on periods; the first part is the name to resolve, any
%% remaining parts should be retained.
%% 2) Walk the context stack from top to bottom, finding the first context
%% that is a) a hash containing the name as a key OR b) an object responding
%% to a method with the given name.
%% 3) If the context is a hash, the data is the value associated with the
%% name.
%% 4) If the context is an object and the method with the given name has an
%% arity of 1, the method SHOULD be called with a String containing the
%% unprocessed contents of the sections; the data is the value returned.
%% 5) Otherwise, the data is the value returned by calling the method with
%% the given name.
%% 6) If any name parts were retained in step 1, each should be resolved
%% against a context stack containing only the result from the former
%% resolution. If any part fails resolution, the result should be considered
%% falsey, and should interpolate as the empty string.
%% If the data is not of a list type, it is coerced into a list as follows: if
%% the data is truthy (e.g. `!!data == true`), use a single-element list
%% containing the data, otherwise use an empty list.
%%
%% For each element in the data list, the element MUST be pushed onto the
%% context stack, the section MUST be rendered, and the element MUST be popped
%% off the context stack.
%%
%% Section and End Section tags SHOULD be treated as standalone when
%% appropriate.
%%
%% @end

-module(sections_test).

-include_lib("eunit/include/eunit.hrl").

-define(TO_LIST(Something), unicode:characters_to_list(Something)).

%% @doc Truthy sections should have their contents rendered.
truthy_test() ->
    Template = <<"\"{{#boolean}}This should be rendered.{{/boolean}}\"">>,
    Data = #{boolean => true},
    Expected = <<"\"This should be rendered.\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Falsey sections should have their contents omitted.
falsey_test() ->
    Template = <<"\"{{#boolean}}This should not be rendered.{{/boolean}}\"">>,
    Data = #{boolean => false},
    Expected = <<"\"\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Null is falsey.
null_is_falsey_test() ->
    Template = <<"\"{{#null}}This should not be rendered.{{/null}}\"">>,
    Data = #{null => null},
    Expected = <<"\"\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Objects and hashes should be pushed onto the context stack.
context_test() ->
    Template = <<"\"{{#context}}Hi {{name}}.{{/context}}\"">>,
    Data = #{context => #{name => <<"Joe">>}},
    Expected = <<"\"Hi Joe.\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Names missing in the current context are looked up in the stack.
parent_contexts_test() ->
    Template = <<"\"{{#sec}}{{a}}, {{b}}, {{c.d}}{{/sec}}\"">>,
    Data = #{a => <<"foo">>,b => <<"wrong">>,
             c => #{d => <<"baz">>},
             sec => #{b => <<"bar">>}},
    Expected = <<"\"foo, bar, baz\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Non-false sections have their value at the top of context,
%% accessible as {{.}} or through the parent context. This gives
%% a simple way to display content conditionally if a variable exists.
%%
%% @end
variable_test_test() ->
    Template = <<"\"{{#foo}}{{.}} is {{foo}}{{/foo}}\"">>,
    Data = #{foo => <<"bar">>},
    Expected = <<"\"bar is bar\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc All elements on the context stack should be accessible within lists.
list_contexts_test() ->
    Template = <<"{{#tops}}{{#middles}}{{tname.lower}}{{mname}}.{{#bottoms}}{{tname.upper}}{{mname}}{{bname}}.{{/bottoms}}{{/middles}}{{/tops}}">>,
    Data = #{tops =>
                 [#{middles =>
                        [#{bottoms =>
                               [#{bname => <<"x">>},#{bname => <<"y">>}],
                           mname => <<"1">>}],
                    tname => #{lower => <<"a">>,upper => <<"A">>}}]},
    Expected = <<"a1.A1x.A1y.">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc All elements on the context stack should be accessible.
deeply_nested_contexts_test() ->
    Template = <<"{{#a}}\n{{one}}\n{{#b}}\n{{one}}{{two}}{{one}}\n{{#c}}\n{{one}}{{two}}{{three}}{{two}}{{one}}\n{{#d}}\n{{one}}{{two}}{{three}}{{four}}{{three}}{{two}}{{one}}\n{{#five}}\n{{one}}{{two}}{{three}}{{four}}{{five}}{{four}}{{three}}{{two}}{{one}}\n{{one}}{{two}}{{three}}{{four}}{{.}}6{{.}}{{four}}{{three}}{{two}}{{one}}\n{{one}}{{two}}{{three}}{{four}}{{five}}{{four}}{{three}}{{two}}{{one}}\n{{/five}}\n{{one}}{{two}}{{three}}{{four}}{{three}}{{two}}{{one}}\n{{/d}}\n{{one}}{{two}}{{three}}{{two}}{{one}}\n{{/c}}\n{{one}}{{two}}{{one}}\n{{/b}}\n{{one}}\n{{/a}}\n">>,
    Data = #{a => #{one => 1},
             b => #{two => 2},
             c => #{d => #{five => 5,four => 4},three => 3}},
    Expected = <<"1\n121\n12321\n1234321\n123454321\n12345654321\n123454321\n1234321\n12321\n121\n1\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Lists should be iterated; list items should visit the context stack.
list_test() ->
    Template = <<"\"{{#list}}{{item}}{{/list}}\"">>,
    Data = #{list => [#{item => 1},#{item => 2},#{item => 3}]},
    Expected = <<"\"123\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Empty lists should behave like falsey values.
empty_list_test() ->
    Template = <<"\"{{#list}}Yay lists!{{/list}}\"">>,
    Data = #{list => []},
    Expected = <<"\"\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Multiple sections per template should be permitted.
doubled_test() ->
    Template = <<"{{#bool}}\n* first\n{{/bool}}\n* {{two}}\n{{#bool}}\n* third\n{{/bool}}\n">>,
    Data = #{bool => true,two => <<"second">>},
    Expected = <<"* first\n* second\n* third\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Nested truthy sections should have their contents rendered.
nested_truthy_test() ->
    Template = <<"| A {{#bool}}B {{#bool}}C{{/bool}} D{{/bool}} E |">>,
    Data = #{bool => true},
    Expected = <<"| A B C D E |">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Nested falsey sections should be omitted.
nested_falsey_test() ->
    Template = <<"| A {{#bool}}B {{#bool}}C{{/bool}} D{{/bool}} E |">>,
    Data = #{bool => false},
    Expected = <<"| A  E |">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Failed context lookups should be considered falsey.
context_misses_test() ->
    Template = <<"[{{#missing}}Found key 'missing'!{{/missing}}]">>,
    Data = #{},
    Expected = <<"[]">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Implicit iterators should directly interpolate strings.
implicit_iterator_string_test() ->
    Template = <<"\"{{#list}}({{.}}){{/list}}\"">>,
    Data = #{list => [<<"a">>,<<"b">>,<<"c">>,<<"d">>,<<"e">>]},
    Expected = <<"\"(a)(b)(c)(d)(e)\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Implicit iterators should cast integers to strings and interpolate.
implicit_iterator_integer_test() ->
    Template = <<"\"{{#list}}({{.}}){{/list}}\"">>,
    Data = #{list => [1,2,3,4,5]},
    Expected = <<"\"(1)(2)(3)(4)(5)\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Implicit iterators should cast decimals to strings and interpolate.
implicit_iterator_decimal_test() ->
    Template = <<"\"{{#list}}({{.}}){{/list}}\"">>,
    Data = #{list => [1.1,2.2,3.3,4.4,5.5]},
    Expected = <<"\"(1.1)(2.2)(3.3)(4.4)(5.5)\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Implicit iterators should allow iterating over nested arrays.
implicit_iterator_array_test() ->
    Template = <<"\"{{#list}}({{#.}}{{.}}{{/.}}){{/list}}\"">>,
    Data = #{list => [[1,2,3],[<<"a">>,<<"b">>,<<"c">>]]},
    Expected = <<"\"(123)(abc)\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Dotted names should be valid for Section tags.
dotted_names_truthy_test() ->
    Template = <<"\"{{#a.b.c}}Here{{/a.b.c}}\" == \"Here\"">>,
    Data = #{a => #{b => #{c => true}}},
    Expected = <<"\"Here\" == \"Here\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Dotted names should be valid for Section tags.
dotted_names_falsey_test() ->
    Template = <<"\"{{#a.b.c}}Here{{/a.b.c}}\" == \"\"">>,
    Data = #{a => #{b => #{c => false}}},
    Expected = <<"\"\" == \"\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Dotted names that cannot be resolved should be considered falsey.
dotted_names_broken_chains_test() ->
    Template = <<"\"{{#a.b.c}}Here{{/a.b.c}}\" == \"\"">>,
    Data = #{a => #{}},
    Expected = <<"\"\" == \"\"">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Sections should not alter surrounding whitespace.
surrounding_whitespace_test() ->
    Template = <<" | {{#boolean}}\t|\t{{/boolean}} | \n">>,
    Data = #{boolean => true},
    Expected = <<" | \t|\t | \n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Sections should not alter internal whitespace.
internal_whitespace_test() ->
    Template = <<" | {{#boolean}} {{! Important Whitespace }}\n {{/boolean}} | \n">>,
    Data = #{boolean => true},
    Expected = <<" |  \n  | \n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Single-line sections should not alter surrounding whitespace.
indented_inline_sections_test() ->
    Template = <<" {{#boolean}}YES{{/boolean}}\n {{#boolean}}GOOD{{/boolean}}\n">>,
    Data = #{boolean => true},
    Expected = <<" YES\n GOOD\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Standalone lines should be removed from the template.
standalone_lines_test() ->
    Template = <<"| This Is\n{{#boolean}}\n|\n{{/boolean}}\n| A Line\n">>,
    Data = #{boolean => true},
    Expected = <<"| This Is\n|\n| A Line\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Indented standalone lines should be removed from the template.
indented_standalone_lines_test() ->
    Template = <<"| This Is\n  {{#boolean}}\n|\n  {{/boolean}}\n| A Line\n">>,
    Data = #{boolean => true},
    Expected = <<"| This Is\n|\n| A Line\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc "\r\n" should be considered a newline for standalone tags.
standalone_line_endings_test() ->
    Template = <<"|\r\n{{#boolean}}\r\n{{/boolean}}\r\n|">>,
    Data = #{boolean => true},
    Expected = <<"|\r\n|">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Standalone tags should not require a newline to precede them.
standalone_without_previous_line_test() ->
    Template = <<"  {{#boolean}}\n#{{/boolean}}\n/">>,
    Data = #{boolean => true},
    Expected = <<"#\n/">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Standalone tags should not require a newline to follow them.
standalone_without_newline_test() ->
    Template = <<"#{{#boolean}}\n/\n  {{/boolean}}">>,
    Data = #{boolean => true},
    Expected = <<"#\n/\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Superfluous in-tag whitespace should be ignored.
padding_test() ->
    Template = <<"|{{# boolean }}={{/ boolean }}|">>,
    Data = #{boolean => true},
    Expected = <<"|=|">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).
