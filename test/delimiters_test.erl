%% --------------------------------------------------
%% DO NOT EDIT THIS FILE
%% It was generated automatically from the following specs
%% ./mustache-spec/specs/delimiters.json
%% Fetched from this repository
%% https://github.com/mustache/spec
%%
%% date: 2022-10-20 19:49:18
%% @version v0.0.0
%% @reference Eptwalabha, https://github.com/Eptwalabha.
%%
%% @doc Set Delimiter tags are used to change the tag delimiters for all
%% content
%% following the tag in the current compilation unit.
%%
%% The tag's content MUST be any two non-whitespace sequences (separated by
%% whitespace) EXCEPT an equals sign ('=') followed by the current closing
%% delimiter.
%%
%% Set Delimiter tags SHOULD be treated as standalone when appropriate.
%%
%% @end

-module(delimiters_test).

-include_lib("eunit/include/eunit.hrl").

-define(TO_LIST(Something), unicode:characters_to_list(Something)).

%% @doc The equals sign (used on both sides) should permit delimiter changes.
pair_behavior_test() ->
    Template = <<"{{=<% %>=}}(<%text%>)">>,
    Data = #{text => <<"Hey!">>},
    Expected = <<"(Hey!)">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Characters with special meaning regexen should be valid delimiters.
special_characters_test() ->
    Template = <<"({{=[ ]=}}[text])">>,
    Data = #{text => <<"It worked!">>},
    Expected = <<"(It worked!)">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Delimiters set outside sections should persist.
sections_test() ->
    Template = <<"[\n{{#section}}\n  {{data}}\n  |data|\n{{/section}}\n\n{{= | | =}}\n|#section|\n  {{data}}\n  |data|\n|/section|\n]\n">>,
    Data = #{data => <<"I got interpolated.">>,section => true},
    Expected = <<"[\n  I got interpolated.\n  |data|\n\n  {{data}}\n  I got interpolated.\n]\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Delimiters set outside inverted sections should persist.
inverted_sections_test() ->
    Template = <<"[\n{{^section}}\n  {{data}}\n  |data|\n{{/section}}\n\n{{= | | =}}\n|^section|\n  {{data}}\n  |data|\n|/section|\n]\n">>,
    Data = #{data => <<"I got interpolated.">>,section => false},
    Expected = <<"[\n  I got interpolated.\n  |data|\n\n  {{data}}\n  I got interpolated.\n]\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Delimiters set in a parent template should not affect a partial.
partial_inheritence_test() ->
    Template = <<"[ {{>include}} ]\n{{= | | =}}\n[ |>include| ]\n">>,
    Data = #{value => <<"yes">>},
    Partials = #{ include => ".{{value}}." },
    Expected = <<"[ .yes. ]\n[ .yes. ]\n">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Delimiters set in a partial should not affect the parent template.
postpartial_behavior_test() ->
    Template = <<"[ {{>include}} ]\n[ .{{value}}.  .|value|. ]\n">>,
    Data = #{value => <<"yes">>},
    Partials = #{ include => ".{{value}}. {{= | | =}} .|value|." },
    Expected = <<"[ .yes.  .yes. ]\n[ .yes.  .|value|. ]\n">>,
    ?assertEqual(?TO_LIST(Expected),
                 mustache:render(Template, Data, Partials)).

%% @doc Surrounding whitespace should be left untouched.
surrounding_whitespace_test() ->
    Template = <<"| {{=@ @=}} |">>,
    Data = #{},
    Expected = <<"|  |">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Whitespace should be left untouched.
outlying_whitespace_inline_test() ->
    Template = <<" | {{=@ @=}}\n">>,
    Data = #{},
    Expected = <<" | \n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Standalone lines should be removed from the template.
standalone_tag_test() ->
    Template = <<"Begin.\n{{=@ @=}}\nEnd.\n">>,
    Data = #{},
    Expected = <<"Begin.\nEnd.\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Indented standalone lines should be removed from the template.
indented_standalone_tag_test() ->
    Template = <<"Begin.\n  {{=@ @=}}\nEnd.\n">>,
    Data = #{},
    Expected = <<"Begin.\nEnd.\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc "\r\n" should be considered a newline for standalone tags.
standalone_line_endings_test() ->
    Template = <<"|\r\n{{= @ @ =}}\r\n|">>,
    Data = #{},
    Expected = <<"|\r\n|">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Standalone tags should not require a newline to precede them.
standalone_without_previous_line_test() ->
    Template = <<"  {{=@ @=}}\n=">>,
    Data = #{},
    Expected = <<"=">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Standalone tags should not require a newline to follow them.
standalone_without_newline_test() ->
    Template = <<"=\n  {{=@ @=}}">>,
    Data = #{},
    Expected = <<"=\n">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).

%% @doc Superfluous in-tag whitespace should be ignored.
pair_with_padding_test() ->
    Template = <<"|{{= @   @ =}}|">>,
    Data = #{},
    Expected = <<"||">>,
    ?assertEqual(?TO_LIST(Expected), mustache:render(Template, Data)).
